#!/usr/bin/env bash

readonly PROGDIR=$(cd "${0%/*}" && pwd)

branch=$(
  git branch --all --sort=-committerdate |
  grep -v "HEAD ->" |
  cut -c 3- |
  # Use awk to separate remote and local branches, and only show remote
  # branches that don't have a corresponding local branch (including current branch)
  awk '
    /^\* / { current=substr($0, 3); next }
    /^remotes\// {
      remote[$0] = 1
        order[++count] = $0
        sub(/^remotes\/[^\/]+\//, "");
        remotes[$0] = 1;
        next
    }
    { local[$0] = 1 }
    END {
      for (i = 1; i <= count; i++) {
        r = order[i]
          short_r = r
          sub(/^remotes\/[^\/]+\//, "", short_r)
          if (!(short_r in local) && short_r != current) print r
      }
    }
  ' | (
    if command -v fzf > /dev/null; then
      fzf --height=40% --reverse --info=inline --preview="git branch-commits {}"
    else
      ${PROGDIR}/selecta
    fi
  )
)

# Check if branch is of pattern remotes/<remote>/<branch>
if [[ $branch == remotes/* ]]; then
    # Extract remote and branch name
    remote_branch=${branch#remotes/}  # Remove "remotes/" prefix
    remote=${remote_branch%%/*}       # Extract remote name (everything before first /)
    branch_name=${remote_branch#*/}   # Extract branch name (everything after first /)

    # Create and checkout new local branch tracking the remote
    git checkout -b "$branch_name" "$remote/$branch_name"
else
    # Just checkout the existing local branch
    git checkout "$branch"
fi
